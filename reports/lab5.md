# lab5

计86 罗境佳 2018013469



## 实验报告

### 实验指导

### 编程作业

需要增加 `spawn` 的系统调用，其本质上是先 `fork` 再 `exec`，实现见 `crate::syscall::process::sys_spawn`。

具体是先让 `current_task` fork 出一个子进程，之后调用子进程的 `exec` 函数，并添加进任务列表。



## 问答作业

1.  **fork + exec 的一个比较大的问题是 fork 之后的内存页/文件等资源完全没有使用就废弃了，针对这一点，有什么改进策略？**

    可以使用 Write On Copy 策略，即 fork 之后并没有真正分配新的物理内存，而是与父进程公用一块物理内存，这点可以通过虚存机制实现；等到新进程写的时候再真正为它分配物理内存资源。

    在 fork + exec 的例子里，在 exec 的时候才真正分配物理内存资源并将源代码及数据加载进来。

2.  其实使用了题(1)的策略之后，fork + exec 所带来的无效资源的问题已经基本被解决了，但是今年来 fork 还是在被不断的批判，那么到底是什么正在”杀死”fork？可以参考 [论文](https://www.microsoft.com/en-us/research/uploads/prod/2019/04/fork-hotos19.pdf) ，**注意**：回答无明显错误就给满分，出这题只是想引发大家的思考，完全不要求看论文，球球了，别卷了。

3.  **fork 当年被设计并称道肯定是有其好处的。请使用带初始参数的 spawn 重写如下 fork 程序，然后描述 fork 有那些好处。注意:使用”伪代码”传达意思即可，spawn 接口可以自定义。可以写多个文件。**

    ```
    fn main() {
        let a = get_a();
        spawn("add\0");
        println!("a = {}", a);
        0
    }
    
    // add.rs
    fn main() {
    	let a = get_a();
    	let b = get_b();
    	println!("a + b = {}", a + b);
    	exit(0);
    }
    ```

4.  **描述进程执行的几种状态，以及 fork/exec/wait/exit 对于状态的影响。**

    状态：创建，就绪，运行，等待，退出。

    -   fork：进程进行系统调用，由运行状态变为运行状态；fork 出的子进程被创建，为就绪状态。
    -   exec：进程由运行状态变为运行状态。
    -   wait：进程由运行变为等待，直到子进程变为退出状态（僵尸进程）时才进入就绪状态。
    -   exit：进程由运行变为退出。
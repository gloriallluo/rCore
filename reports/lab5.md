# lab5

计86 罗境佳 2018013469



## 实验报告

### 实验指导

本节实验实现了进程（在之前的 Task 的基础上新增加了进程标识符、`KernelStack` 数据结构、进程之间的父子关系等等），并且实现了 `fork`、`exec`、`spawn` 等系统调用，并且实现了一个命令行交互程序。在初始化的时候，会建立一个名为 `initproc` 的进程，接着由这个进程进行 `exec` 的系统调用并且执行 `usershell` 程序。

-   fork 的过程：调用 `current_task.fork()`，新建一个子进程的 `TCB`，复制 `current_task` 的地址空间、内核栈、以及 TCB 里的其他参数。接着将子进程的 `a0` 寄存器置 0，并将紫禁城加入就绪队列。
-   exec 的过程：根据应用名字找到对应的 elf 文件并将地址空间、用户栈、执行流等等赋给当前进程。
-   回收进程资源的过程：将当前进程标为僵尸进程，将所有子进程托管给 `initproc`，并回收所有地质资源。

### 编程作业

需要增加 `spawn` 的系统调用，其本质上是先 `fork` 再 `exec`，实现见 `crate::syscall::process::sys_spawn`。

具体是先让 `current_task` fork 出一个子进程，之后调用子进程的 `exec` 函数，并添加进任务列表。



## 问答作业

1.  **fork + exec 的一个比较大的问题是 fork 之后的内存页/文件等资源完全没有使用就废弃了，针对这一点，有什么改进策略？**

    可以使用 Write On Copy 策略，即 fork 之后并没有真正分配新的物理内存，而是与父进程公用一块物理内存，这点可以通过虚存机制实现；等到新进程写的时候再真正为它分配物理内存资源。

    在 fork + exec 的例子里，在 exec 的时候才真正分配物理内存资源并将源代码及数据加载进来。

    

2.  **其实使用了题(1)的策略之后，fork + exec 所带来的无效资源的问题已经基本被解决了，但是今年来 fork 还是在被不断的批判，那么到底是什么正在”杀死”fork？**

    -   fork 经过漫长的演化，对于使用者已经难以理解。
    -   因为对地址空间的复制，导致对于 User Mode 的抽象做的不是很好。
    -   fork 不是线程安全的。
    -   安全性不好，子进程继承父进程的所有资源违反了最小特权原则。
    -   fork 很慢。
    -   fork 的可扩展性较差。
    -   即使使用了 Copy On Write 也有可能导致过度分配内存。

    

3.  **fork 当年被设计并称道肯定是有其好处的。请使用带初始参数的 spawn 重写如下 fork 程序，然后描述 fork 有那些好处。注意：使用”伪代码”传达意思即可，spawn 接口可以自定义。可以写多个文件。**

    ```rust
    fn main() {
        let a = get_a();
        /// `spawn` params: (name, args)
        spawn("add", a);
        println!("a = {}", a);
        0
    }
    ```

    ```rust
    // add.rs
    fn main() {
        let argv = env::args();
    	let a = argv[0];
    	let b = get_b();
    	println!("a + b = {}", a + b);
    	exit(0);
    }
    ```

    

4.  **描述进程执行的几种状态，以及 fork/exec/wait/exit 对于状态的影响。**

    状态：创建，就绪，运行，等待，退出。

    -   fork：进程进行系统调用，由运行状态变为运行状态；fork 出的子进程被创建，为就绪状态。
    -   exec：进程由运行状态变为运行状态。
    -   wait：进程由运行变为等待，直到子进程变为退出状态（僵尸进程）时才进入就绪状态。
    -   exit：进程由运行变为退出。